import type { ScriptService } from "../../app/message-protocol";
import {
  isBooleanArgumentField,
  isEnumArgumentField,
  isNumberArgumentField,
  isStringArgumentField,
  isUserScript,
  UserScript,
} from "../../models/script";
import * as vscode from "vscode";
import { names, paths } from "../constant";
import { existDir, fsextra, glob, path } from "../node-utils";
import * as ts from "typescript";
import { die } from "taio/build/utils/internal/exceptions";
import { enumValues } from "taio/build/utils/enum";
import { isNumber, isString } from "taio/build/utils/validator/primitive";
const f = ts.factory;
export function createScriptService(
  context: vscode.ExtensionContext
): ScriptService {
  function basedOnExtension(...fragments: string[]) {
    return path.resolve(context.extensionPath, ...fragments);
  }
  function basedOnScripts(...fragments: string[]) {
    return basedOnExtension(paths.userScripts, ...fragments);
  }
  function isValidScriptName(name: string) {
    const special = new Set([..."~`!@#$%^&*()_+-={}|[]\\:;\"'<>?,./"]);
    return ![...name].some((char) => special.has(char));
  }
  return {
    async check() {
      await fsextra.ensureDir(basedOnScripts());
    },
    async create(script) {
      if (!isValidScriptName(script.name)) {
        vscode.window.showErrorMessage(`Invalid script name!`);
        return;
      }
      if (!isUserScript(script)) {
        vscode.window.showInformationMessage(`Invalid script object!`);
        return;
      }
      const scriptHome = basedOnScripts(script.name);
      if (await existDir(scriptHome)) {
        vscode.window.showInformationMessage(
          `Script <${script.name}> already exists`
        );
        return;
      }
      await fsextra.ensureDir(scriptHome);
      await Promise.all([
        fsextra.writeJSON(basedOnScripts(script.name, paths.meta), script),
        fsextra.writeFile(
          basedOnScripts(script.name, paths.declaration),
          `// This file is generated by the extension.
// NEVER MODIFY IT!

${getConfigTsDeclCodeOfUserScript(script)}`
        ),
      ]);
    },
    async delete(script) {
      const scriptHost = basedOnScripts(script.name);
      if (!(await existDir(scriptHost))) {
        vscode.window.showErrorMessage(`Script ${script.name} not found!`);
        return;
      }
      await fsextra.rm(scriptHost);
      vscode.window.showInformationMessage(`Script ${script.name} Removed.`);
    },
    async getList() {
      const base = path.resolve(context.extensionPath);
      const metas = await glob(`**/${paths.meta}`, {
        cwd: base,
      });
      const jsons = await Promise.all(
        metas.map((meta) => fsextra.readJSON(meta))
      );
      return jsons.filter(isUserScript);
    },
  };
}

interface ScriptFolderContents {
  script: string;
  meta: UserScript;
  declaration: string;
}

function getConfigTsDeclCodeOfUserScript(script: UserScript): string {
  return ts.createPrinter().printNode(
    ts.EmitHint.Unspecified,
    f.createInterfaceDeclaration(
      /** decorators */ undefined,
      /** modifiers */ [f.createModifier(ts.SyntaxKind.ExportKeyword)],
      f.createIdentifier(names.configName),
      /** type parameters */ [],
      /** heritage clauses */ [],
      /** members */ Object.entries(script.argumentConfig).map(([key, field]) =>
        f.createPropertySignature(
          [f.createModifier(ts.SyntaxKind.ReadonlyKeyword)],
          key,
          undefined,
          isStringArgumentField(field)
            ? f.createKeywordTypeNode(ts.SyntaxKind.StringKeyword)
            : isNumberArgumentField(field)
            ? f.createKeywordTypeNode(ts.SyntaxKind.NumberKeyword)
            : isBooleanArgumentField(field)
            ? f.createKeywordTypeNode(ts.SyntaxKind.BooleanKeyword)
            : isEnumArgumentField(field)
            ? f.createUnionTypeNode(
                enumValues(field.enumOptions.enumObject).map((value) =>
                  f.createLiteralTypeNode(
                    isString(value)
                      ? f.createStringLiteral(value)
                      : isNumber(value)
                      ? f.createNumericLiteral(value)
                      : die()
                  )
                )
              )
            : die()
        )
      )
    ),
    ts.createSourceFile(paths.declaration, "", ts.ScriptTarget.ES2015)
  );
}

function getTsTemplate() {
  ts.createPrinter().printNode(
    ts.EmitHint.Unspecified,
    f.createFunctionDeclaration(
      /** decorators */ undefined,
      /** modifiers */ [f.createModifier(ts.SyntaxKind.ExportKeyword)],
      /** asterisk(*) */ undefined,
      /** name */ names.entry,
      /** type parameters <T> */ [],
      /** parameters */ [
        f.createParameterDeclaration(
          /** decorators */ [],
          /** modifiers */ [],
          /** ... */ undefined,
          /** name */ names.param,
          /** ? */ undefined,
          /** type */ f.createImportTypeNode(
            /** import(xxx) */ f.createLiteralTypeNode(
              f.createStringLiteral(`./${paths.declarationBase}`)
            ),
            /** .yyy */ f.createIdentifier(names.configName)
          )
        ),
      ],
      f.createKeywordTypeNode(ts.SyntaxKind.VoidKeyword),
      f.createBlock([])
    ),
    ts.createSourceFile(paths.mainScript, "", ts.ScriptTarget.ES2015)
  );
}
