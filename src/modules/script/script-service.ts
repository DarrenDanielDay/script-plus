import type { ScriptService } from "../../app/message-protocol";
import {
  isBooleanArgumentField,
  isEnumArgumentField,
  isNumberArgumentField,
  isStringArgumentField,
  isUserScript,
  UserScript,
} from "../../models/script";
import * as vscode from "vscode";
import { names, paths } from "../constant";
import { existDir, fsextra, glob, path, randomString } from "../node-utils";
import * as ts from "typescript";
import { die } from "taio/build/utils/internal/exceptions";
import { enumValues } from "taio/build/utils/enum";
import { isNumber, isString } from "taio/build/utils/validator/primitive";
import type { ExecutionTask } from "../../models/execution-task";
const f = ts.factory;
export function createScriptService(
  context: vscode.ExtensionContext
): ScriptService {
  const activeTasks = new Map<string, ExecutionTask>();
  function basedOnExtension(...fragments: string[]) {
    return path.resolve(context.extensionPath, ...fragments);
  }
  function basedOnScripts(...fragments: string[]) {
    return basedOnExtension(paths.userScripts, ...fragments);
  }
  function isValidScriptName(name: string) {
    const special = new Set([..."~`!@#$%^&*()_+-={}|[]\\:;\"'<>?,./"]);
    return ![...name].some((char) => special.has(char));
  }
  function getScriptFileName(script: UserScript): string {
    return `${paths.mainScript}.${script.lang}`;
  }
  function writeMeta(script: UserScript): Promise<void> {
    return fsextra.writeJSON(basedOnScripts(script.name, paths.meta), script, {
      spaces: 2,
    });
  }

  function writeDeclaration(script: UserScript): Promise<void> {
    return fsextra.writeFile(
      basedOnScripts(script.name, paths.declaration),
      `// This file is generated by the extension.
// NEVER MODIFY IT!

${getConfigTsDeclCodeOfUserScript(script)}`
    );
  }
  return {
    async check() {
      await fsextra.ensureDir(basedOnScripts());
    },
    async create(script) {
      if (!isValidScriptName(script.name)) {
        vscode.window.showErrorMessage(`Invalid script name!`);
        return;
      }
      if (!isUserScript(script)) {
        vscode.window.showInformationMessage(`Invalid script object!`);
        return;
      }
      const scriptHome = basedOnScripts(script.name);
      if (await existDir(scriptHome)) {
        vscode.window.showInformationMessage(
          `Script <${script.name}> already exists`
        );
        return;
      }
      await fsextra.ensureDir(scriptHome);
      await Promise.all([
        writeMeta(script),
        writeDeclaration(script),
        fsextra.writeFile(
          basedOnScripts(script.name, getScriptFileName(script)),
          getTsTemplate()
        ),
      ]);
    },
    async delete(script) {
      const scriptHost = basedOnScripts(script.name);
      if (!(await existDir(scriptHost))) {
        vscode.window.showErrorMessage(`Script ${script.name} not found!`);
        return;
      }
      fsextra.rmSync(scriptHost, { force: true, recursive: true });
      vscode.window.showInformationMessage(`Script ${script.name} Removed.`);
    },
    async getList() {
      const base = basedOnScripts();
      const metas = await glob(`**/${paths.meta}`, {
        cwd: base,
      });
      const jsons = await Promise.all(
        metas.map((meta) => fsextra.readJSON(path.resolve(base, meta)))
      );
      return jsons.filter(isUserScript);
    },
    async updateScript(script) {
      if (!isUserScript(script)) {
        vscode.window.showErrorMessage(`Invalid script object!`);
        return;
      }
      await Promise.all([writeDeclaration(script), writeMeta(script)]);
    },
    async execute(script) {
      const taskId = randomString(8);
      const executionTask = {
        taskId,
        taskName: script.name,
      };
      activeTasks.set(taskId, executionTask);
      return executionTask;
    },
  };
}

function getConfigTsDeclCodeOfUserScript(script: UserScript): string {
  return ts.createPrinter().printNode(
    ts.EmitHint.Unspecified,
    f.createInterfaceDeclaration(
      /** decorators */ undefined,
      /** modifiers */ [f.createModifier(ts.SyntaxKind.ExportKeyword)],
      f.createIdentifier(names.configName),
      /** type parameters */ [],
      /** heritage clauses */ [],
      /** members */ Object.entries(script.argumentConfig).map(([key, field]) =>
        f.createPropertySignature(
          [f.createModifier(ts.SyntaxKind.ReadonlyKeyword)],
          key,
          undefined,
          isStringArgumentField(field)
            ? f.createKeywordTypeNode(ts.SyntaxKind.StringKeyword)
            : isNumberArgumentField(field)
            ? f.createKeywordTypeNode(ts.SyntaxKind.NumberKeyword)
            : isBooleanArgumentField(field)
            ? f.createKeywordTypeNode(ts.SyntaxKind.BooleanKeyword)
            : isEnumArgumentField(field)
            ? f.createUnionTypeNode(
                enumValues(field.enumOptions.enumObject).map((value) =>
                  f.createLiteralTypeNode(
                    isString(value)
                      ? f.createStringLiteral(value)
                      : isNumber(value)
                      ? f.createNumericLiteral(value)
                      : die()
                  )
                )
              )
            : die()
        )
      )
    ),
    ts.createSourceFile(paths.declaration, "", ts.ScriptTarget.ES2015)
  );
}

function getTsTemplate() {
  return ts
    .createPrinter()
    .printNode(
      ts.EmitHint.Unspecified,
      f.createFunctionDeclaration(
        /** decorators */ undefined,
        /** modifiers */ [f.createModifier(ts.SyntaxKind.ExportKeyword)],
        /** asterisk(*) */ undefined,
        /** name */ names.entry,
        /** type parameters <T> */ [],
        /** parameters */ [
          f.createParameterDeclaration(
            /** decorators */ [],
            /** modifiers */ [],
            /** ... */ undefined,
            /** name */ names.param,
            /** ? */ undefined,
            /** type */ f.createImportTypeNode(
              /** import(xxx) */ f.createLiteralTypeNode(
                f.createStringLiteral(`./${paths.declarationBase}`)
              ),
              /** .yyy */ f.createIdentifier(names.configName)
            )
          ),
        ],
        f.createKeywordTypeNode(ts.SyntaxKind.VoidKeyword),
        f.createBlock([])
      ),
      ts.createSourceFile(paths.mainScript, "", ts.ScriptTarget.ES2015)
    );
}
